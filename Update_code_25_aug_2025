import sys
import os
import re
import numpy as np
import cv2
from pdf2image import convert_from_path
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QPushButton, QLabel, QLineEdit,
    QVBoxLayout, QHBoxLayout, QFileDialog, QTableWidget,
    QTableWidgetItem, QHeaderView, QMessageBox, QAbstractItemView,
    QProgressBar, QSplitter, QTextEdit, QAction, QStyle
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QSize, QMimeData
from PyQt5.QtGui import QColor, QCursor, QPixmap, QDragEnterEvent, QDropEvent, QIcon
from PyPDF2 import PdfReader, PdfWriter
import pytesseract
from ultralytics import YOLO  # YOLO model

# ----------------- PATH SETUP -----------------
if getattr(sys, 'frozen', False):
    base_path = os.path.dirname(sys.executable)
else:
    base_path = os.path.dirname(os.path.abspath(__file__))

candidate_poppler = os.path.join(base_path, 'Release-24.08.0-0', 'poppler-24.08.0', 'Library', 'bin')
poppler_path = candidate_poppler if os.path.isdir(candidate_poppler) else None

yolo_model = YOLO("runs/detect/train8/weights/best.pt")

detected_dir = os.path.join(base_path, "detected_images")
os.makedirs(detected_dir, exist_ok=True)

result_dir = os.path.join(base_path, "result")
os.makedirs(result_dir, exist_ok=True)

# ----------------- STYLING -----------------
APP_QSS = """
* { font-family: Segoe UI, Arial, Helvetica, sans-serif; }
QMainWindow { background: #f7f9fc; }
QLabel#Title { font-size: 22px; font-weight: 700; color: #111827; }
QLabel#Hint { color: #6b7280; font-style: italic; }
QLabel#SectionTitle { font-size: 12px; font-weight: 600; color: #374151; }
QLineEdit { background: white; border: 1px solid #d1d5db; border-radius: 8px; padding: 6px 10px; }
QTableWidget { background: white; border: 1px solid #e5e7eb; border-radius: 10px; }
QHeaderView::section { background: #f3f4f6; border: none; padding: 8px; font-weight: 600; }
QProgressBar { border: 1px solid #d1d5db; border-radius: 8px; background: #ffffff; height: 16px; }
QProgressBar::chunk { background-color: #3b82f6; border-radius: 8px; }
QTextEdit { background: #ffffff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; }
"""

def style_button(button, color="#2563eb", hover_color="#1d4ed8", font_size=12):
    button.setStyleSheet(f"""
        QPushButton {{
            background-color: {color};
            color: white;
            font-weight: 600;
            font-size: {font_size}px;
            border-radius: 10px;
            padding: 8px 14px;
        }}
        QPushButton:hover {{
            background-color: {hover_color};
        }}
        QPushButton:pressed {{
            background-color: #153eaf;
        }}
        QPushButton:disabled {{
            background-color: #9ca3af;
            color: white;
        }}
    """)
    button.setCursor(QCursor(Qt.PointingHandCursor))

# ----------------- WORKER -----------------
class CheckWorker(QThread):
    progress_update = pyqtSignal(int, str)
    add_table_row = pyqtSignal(str, str, str, str, bool, bool, object, object)
    update_summary = pyqtSignal(str, str)
    done = pyqtSignal()
    sorted_file_generated = pyqtSignal(str, str)

    def __init__(self, pdf_paths, poppler_path, detected_dir, result_dir, threshold=3):
        super().__init__()
        self.pdf_paths = pdf_paths
        self.poppler_path = poppler_path
        self.detected_dir = detected_dir
        self.result_dir = result_dir
        self.threshold = threshold
        self._cancel = False

    def cancel(self):
        self._cancel = True

    def detect_stamps(self, img):
        results = yolo_model(img, conf=0.05, iou=0.5, imgsz=1280)
        img_area = img.shape[0] * img.shape[1]
        img_copy = img.copy()
        count_stamp = 0
        final_boxes = []

        def iou(box1, box2):
            xi1 = max(box1[0], box2[0])
            yi1 = max(box1[1], box2[1])
            xi2 = min(box1[2], box2[2])
            yi2 = min(box1[3], box2[3])
            inter_area = max(0, xi2 - xi1) * max(0, yi2 - yi1)
            box1_area = (box1[2] - box1[0]) * (box1[3] - box1[1])
            box2_area = (box2[2] - box2[0]) * (box2[3] - box2[1])
            union_area = box1_area + box2_area - inter_area
            return inter_area / union_area if union_area > 0 else 0

        def is_empty_space(img, x1, y1, x2, y2, white_threshold=0.98):
            crop = img[int(y1):int(y2), int(x1):int(x2)]
            if crop.size == 0:
                return True
            gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
            white_ratio = np.mean(gray > 240)
            return white_ratio > white_threshold

        for box in results[0].boxes:
            cls = int(box.cls[0].cpu().numpy())
            if cls == 0:
                xyxy = box.xyxy[0].cpu().numpy().astype(int)
                x1, y1, x2, y2 = xyxy
                w = x2 - x1
                h = y2 - y1
                area = w * h
                if area < img_area * 0.005 or area > img_area * 0.5:
                    continue
                aspect_ratio = w / h if h > 0 else 0
                if aspect_ratio < 0.7 or aspect_ratio > 1.8:
                    continue
                if is_empty_space(img, x1, y1, x2, y2):
                    continue
                if any(iou([x1, y1, x2, y2], fb) > 0.5 for fb in final_boxes):
                    continue
                final_boxes.append([x1, y1, x2, y2])
                conf = box.conf[0].cpu().numpy()
                label = f'Stamp {conf:.2f}'
                cv2.rectangle(img_copy, (x1, y1), (x2, y2), (0, 180, 0), 3)
                cv2.putText(img_copy, label, (x1, max(0, y1 - 12)),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 160, 0), 2)
                count_stamp += 1

        return count_stamp, img_copy

    def extract_numbers(self, s):
        nums = re.findall(r'\d+', s)
        return [int(num) for num in nums] if nums else [-1]

    def extract_info(self, text):
        do_no_match = re.search(r'DO\s*No\s*:\s*([^\s]+)', text, re.IGNORECASE)
        do_no = do_no_match.group(1) if do_no_match else "UNKNOWN"
        lines = text.splitlines()
        company = "UNKNOWN"
        for idx, line in enumerate(lines):
            if 'Ship To' in line:
                if idx + 1 < len(lines) and lines[idx + 1].strip():
                    company = lines[idx + 1].split("Attention")[0].strip()
                elif idx + 2 < len(lines):
                    company = lines[idx + 2].split("Attention")[0].strip()
                break
        return do_no, company

    def ocr_text_from_image(self, image):
        try:
            return pytesseract.image_to_string(image, config='--psm 6').strip()
        except Exception as e:
            return f"OCR error: {e}"

    def sort_pdf_pages(self, pdf_path, output_path):
        try:
            images = convert_from_path(pdf_path, dpi=300, poppler_path=self.poppler_path)
        except Exception:
            return False

        page_data = []
        for i, pil_img in enumerate(images):
            cv_img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
            text = self.ocr_text_from_image(cv_img)
            do_no, company = self.extract_info(text)
            page_data.append({"index": i, "do_no": do_no, "company": company})

        sorted_pages = sorted(
            page_data,
            key=lambda x: (x["company"].strip().lower(), self.extract_numbers(x["do_no"].strip()))
        )

        try:
            reader = PdfReader(pdf_path)
            writer = PdfWriter()
            for page in sorted_pages:
                writer.add_page(reader.pages[page["index"]])
            with open(output_path, "wb") as f_out:
                writer.write(f_out)
            return True
        except Exception:
            return False

    def run(self):
        total_files = len(self.pdf_paths)
        total_pages = 0
        total_pass = 0
        total_fail = 0
        overall_failed_pages = []

        # Count total pages for progress
        grand_total_pages = sum(len(convert_from_path(p, poppler_path=self.poppler_path)) for p in self.pdf_paths if os.path.isfile(p))
        processed_pages = 0

        for path in self.pdf_paths:
            if self._cancel:
                break
            if not os.path.isfile(path):
                continue

            pages = convert_from_path(path, poppler_path=self.poppler_path)
            filename_only = os.path.basename(path)
            filebase = os.path.splitext(filename_only)[0]

            self.add_table_row.emit(filename_only, "", "", "", True, False, QColor("#111827"), QColor("#e5e7eb"))

            file_pass = 0
            file_fail = 0
            file_failed_pages = []

            for i, page in enumerate(pages):
                if self._cancel:
                    break

                img = cv2.cvtColor(np.array(page), cv2.COLOR_RGB2BGR)
                stamp_count, img_with_boxes = self.detect_stamps(img)

                save_name = f"{filebase}_page_{i+1}_detected.jpg"
                save_path = os.path.join(self.detected_dir, save_name)
                cv2.imwrite(save_path, img_with_boxes)

                is_pass = stamp_count >= self.threshold
                result_text = "PASS" if is_pass else "FAIL"
                fg_color = QColor(0, 128, 0) if is_pass else QColor(200, 0, 0)
                page_with_path = f"Page {i + 1}||{save_path}"

                self.add_table_row.emit(filename_only, page_with_path, str(min(stamp_count, self.threshold)), result_text, False, False, fg_color, None)

                if is_pass:
                    file_pass += 1
                else:
                    file_fail += 1
                    file_failed_pages.append(str(i + 1))

                processed_pages += 1
                percent = int(100 * processed_pages / max(1, grand_total_pages))
                self.progress_update.emit(percent, f"Processing {filename_only}: Page {i + 1}")

            # File summary
            self.add_table_row.emit(
                f"Summary for {filename_only}",
                f"Pages Passed: {file_pass}",
                f"Pages Failed: {file_fail}",
                "Sorted: pending",
                True, True, QColor("#1f4ed8"), QColor("#e0e7ff")
            )

            output_sorted_pdf = os.path.join(self.result_dir, filebase + "_sorted.pdf")
            self.progress_update.emit(int(100 * processed_pages / max(1, grand_total_pages)), f"Sorting {filename_only}...")
            if self.sort_pdf_pages(path, output_sorted_pdf):
                self.sorted_file_generated.emit(os.path.basename(output_sorted_pdf), output_sorted_pdf)

            total_pages += len(pages)
            total_pass += file_pass
            total_fail += file_fail
            if file_fail > 0:
                overall_failed_pages.append(f"{filename_only} (Pages: {', '.join(file_failed_pages)})")

        summary = f"Total Files: {total_files}    |    Total Pages: {total_pages}    |    Total Passed: {total_pass}    |    Total Failed: {total_fail}"
        failed_text = "All pages passed successfully." if not overall_failed_pages else "Failed Pages:\n" + "\n".join(overall_failed_pages)
        self.update_summary.emit(summary, failed_text)
        self.done.emit()
        

# ----------------- DRAG & DROP -----------------
class DropWidget(QWidget):
    files_dropped = pyqtSignal(list)

    def __init__(self, target_lineedit: QLineEdit, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.target_lineedit = target_lineedit

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        paths = [url.toLocalFile() for url in event.mimeData().urls() if url.toLocalFile().lower().endswith(".pdf")]
        if paths:
            self.files_dropped.emit(paths)


# ----------------- MAIN WINDOW -----------------
class StampCheckerMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Stamp Checker")
        self.setMinimumSize(1200, 760)
        self.pdf_paths = []
        self.worker = None
        self._init_ui()

    def _init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)

        # Left panel
        left = QVBoxLayout()
        title_label = QLabel("Stamp Checker"); title_label.setObjectName("Title")
        left.addWidget(title_label)

        # File picker
        file_row = QHBoxLayout()
        self.file_entry = QLineEdit(); self.file_entry.setReadOnly(True)
        file_row.addWidget(self.file_entry)
        browse_btn = QPushButton("Browse"); style_button(browse_btn)
        browse_btn.setFixedWidth(110); browse_btn.clicked.connect(self.browse_files)
        file_row.addWidget(browse_btn)
        left.addLayout(file_row)
        hint = QLabel("Tip: You can also drag & drop PDF files anywhere in this window."); hint.setObjectName("Hint")
        left.addWidget(hint)

        # Action buttons
        actions_row = QHBoxLayout()
        self.check_sort_btn = QPushButton("Check Stamps + Sort"); style_button(self.check_sort_btn, "#059669", "#047857")
        self.check_sort_btn.setEnabled(False); self.check_sort_btn.clicked.connect(self.run_check_and_sort)
        actions_row.addWidget(self.check_sort_btn)
        self.sort_only_btn = QPushButton("Sort Only"); style_button(self.sort_only_btn, "#2563eb", "#1d4ed8")
        self.sort_only_btn.setEnabled(False); self.sort_only_btn.clicked.connect(self.run_sort_only)
        actions_row.addWidget(self.sort_only_btn)
        left.addLayout(actions_row)

        # Open result folder
        folders_row = QHBoxLayout()
        self.open_result_btn = QPushButton("Open Result Folder"); style_button(self.open_result_btn, "#6b7280", "#4b5563")
        self.open_result_btn.clicked.connect(lambda: self.open_in_explorer(result_dir))
        folders_row.addWidget(self.open_result_btn)
        left.addLayout(folders_row)

        # Summary
        left.addWidget(QLabel("Run Summary", objectName="SectionTitle"))
        self.summary_label = QLabel(""); self.summary_label.setWordWrap(True)
        left.addWidget(self.summary_label)

        left.addWidget(QLabel("Failed Pages", objectName="SectionTitle"))
        self.failed_pages_text = QTextEdit(); self.failed_pages_text.setReadOnly(True)
        left.addWidget(self.failed_pages_text)
        left.addStretch(1)

        # Right panel
        right = QVBoxLayout()
        right.addWidget(QLabel("Results", objectName="SectionTitle"))
        self.table = QTableWidget(); self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["File", "Page", "Stamps Found", "Result"])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setAlternatingRowColors(True)
        right.addWidget(self.table, stretch=2)

        # Splitter
        splitter = QSplitter(Qt.Horizontal)
        left_container = QWidget(); left_container.setLayout(left)
        right_container = QWidget(); right_container.setLayout(right)
        splitter.addWidget(left_container)
        splitter.addWidget(right_container)
        splitter.setSizes([420, 780])

        # Bottom progress
        bottom_row = QHBoxLayout()
        self.progress_bar = QProgressBar(); self.progress_bar.setRange(0, 100); self.progress_bar.setValue(0); self.progress_bar.setVisible(False)
        bottom_row.addWidget(self.progress_bar)

        wrapper = QVBoxLayout(central)
        dropper = DropWidget(self.file_entry, central)
        dropper.files_dropped.connect(self.on_files_dropped)
        wrapper.addWidget(dropper)
        dropper.setLayout(QVBoxLayout())
        dropper.layout().addWidget(splitter)
        dropper.layout().addLayout(bottom_row)

        # Status bar
        self.statusBar().showMessage("Ready")
        self.setStyleSheet(APP_QSS)

    # ----------------- FILE HANDLING -----------------
    def browse_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select PDF files", "", "PDF Files (*.pdf)")
        if files:
            self.set_files(files)

    def on_files_dropped(self, files):
        self.set_files(files)

    def set_files(self, files):
        self.pdf_paths = files
        self.file_entry.setText(", ".join([os.path.basename(f) for f in files]))
        self.check_sort_btn.setEnabled(True); self.sort_only_btn.setEnabled(True)
        self.table.setRowCount(0); self.summary_label.setText(""); self.failed_pages_text.clear()
        self.statusBar().showMessage(f"Loaded {len(files)} PDF(s)")

    # ----------------- RUN ACTIONS -----------------
    def run_check_and_sort(self):
        if not self.pdf_paths:
            QMessageBox.warning(self, "Error", "Please select at least one PDF file."); return
        self.table.setRowCount(0); self.failed_pages_text.clear(); self.summary_label.setText("")
        self.check_sort_btn.setEnabled(False); self.sort_only_btn.setEnabled(False)
        self.progress_bar.setVisible(True); self.progress_bar.setValue(0)

        self.worker = CheckWorker(self.pdf_paths, poppler_path, detected_dir, result_dir)
        self.worker.add_table_row.connect(self.insert_table_row)
        self.worker.update_summary.connect(self.update_summary_labels)
        self.worker.done.connect(self.on_check_finished)
        self.worker.sorted_file_generated.connect(self.on_sorted_file_generated)
        self.worker.progress_update.connect(self.on_progress_update)
        self.worker.start()
        self.statusBar().showMessage("Checking stamps and sortingâ€¦")

    def run_sort_only(self):
        if not self.pdf_paths:
            QMessageBox.warning(self, "Error", "Please select at least one PDF file."); return
        for path in self.pdf_paths:
            base_name = os.path.splitext(os.path.basename(path))[0]
            output_sorted_pdf = os.path.join(result_dir, base_name + "_sorted.pdf")
            worker = CheckWorker([path], poppler_path, detected_dir, result_dir)
            if worker.sort_pdf_pages(path, output_sorted_pdf):
                QMessageBox.information(self, "Sorted PDF Generated", f"Sorted PDF saved as:\n{output_sorted_pdf}")
        self.statusBar().showMessage("Sorting complete.")

    # ----------------- TABLE & SUMMARY -----------------
    def insert_table_row(self, col_file, col_page, col_count, col_result, bold=False, italic=False, fg_color=None, bg_color=None):
        row_idx = self.table.rowCount(); self.table.insertRow(row_idx)
        img_path = None; show_text = col_page
        if "||" in col_page: show_text, img_path = col_page.split("||", 1)
        def make_item(text):
            it = QTableWidgetItem(text)
            f = it.font()
            f.setPointSize(10)
            f.setBold(bold)
            f.setItalic(italic)
            it.setFont(f)
            it.setForeground(fg_color or QColor(30, 30, 30))
            if bg_color:
                it.setBackground(bg_color)
            return it
        items = [make_item(col_file), make_item(show_text), make_item(col_count), make_item(col_result)]
        if img_path: items[1].setData(Qt.UserRole, img_path)
        for c, it in enumerate(items): self.table.setItem(row_idx, c, it)
        # Color PASS/FAIL background lightly
        if col_result.upper() == "PASS": [self.table.item(row_idx, c).setBackground(QColor("#ecfdf5")) for c in range(4)]
        elif col_result.upper() == "FAIL": [self.table.item(row_idx, c).setBackground(QColor("#fef2f2")) for c in range(4)]

    def update_summary_labels(self, summary_text, failed_text):
        self.summary_label.setText(summary_text)
        self.failed_pages_text.setPlainText(failed_text)
        self.failed_pages_text.setStyleSheet("color: #b91c1c;" if failed_text.startswith("Failed Pages") else "color: #065f46; font-weight: 600;")

    def on_sorted_file_generated(self, filename, filepath):
        for r in range(self.table.rowCount() - 1, -1, -1):
            if self.table.item(r, 0) and str(self.table.item(r, 0).text()).startswith("Summary for"):
                self.table.setItem(r, 3, QTableWidgetItem(f"Sorted: {os.path.basename(filepath)}"))
                break
        QMessageBox.information(self, "Sorted PDF Generated", f"Sorted PDF saved as:\n{filepath}")

    def on_progress_update(self, percent, message):
        self.progress_bar.setValue(percent)
        self.statusBar().showMessage(message)

    def on_check_finished(self):
        self.progress_bar.setVisible(False)
        self.check_sort_btn.setEnabled(True)
        self.sort_only_btn.setEnabled(True)
        self.statusBar().showMessage("Done")

    # ----------------- UTILITIES -----------------
    def open_in_explorer(self, path):
        try: os.startfile(path)
        except Exception as e: QMessageBox.warning(self, "Open Folder", f"Failed to open folder:\n{e}")


# ----------------- RUN -----------------
def main():
    app = QApplication(sys.argv)
    app.setWindowIcon(QIcon.fromTheme("applications-graphics"))
    window = StampCheckerMainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
